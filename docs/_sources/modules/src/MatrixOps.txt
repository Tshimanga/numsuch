.. default-domain:: chpl

.. module:: MatrixOps

MatrixOps
=========
**Usage**

.. code-block:: chapel

   use MatrixOps;

.. data:: config param batchsize = 10000

.. class:: NamedMatrix

   
   A matrix of data with named rows and columns.
   


   .. attribute:: var D: domain(2)

   .. attribute:: var SD = CSRDomain(D)

   .. attribute:: var X: [SD] real

   .. attribute:: var rows: BiMap = new BiMap()

   .. attribute:: var cols: BiMap = new BiMap()

   .. method:: proc init()

   .. method:: proc init(X)

.. method:: proc NamedMatrix.loadX(X: [], shape: 2*(int) = (-1, -1))

   
   Loads the data from X into the internal array, also called X.  We call them all X to keep it clear.
   
   :arg real[]: Array representing the matrix
    

.. method:: proc NamedMatrix.setRowNames(rn: []): string throws

   
   Sets the row names for the matrix X
    

.. method:: proc NamedMatrix.setColNames(cn: []): string throws

   
   Sets the column names for the matrix X

.. method:: proc NamedMatrix.get(i: int, j: int)

   
   Gets the value of the (i,j) entry of the matrix X in the NamedMatrix
   

.. method:: proc NamedMatrix.get(f: string, t: string)

   
   Get the values using the named rows and columns
    

.. method:: proc NamedMatrix.set(i: int, j: int, w: real)

   
   Set the value of this.X(i,j) by index row
   

.. method:: proc NamedMatrix.set(f: string, t: string, w: real)

   
   Set the values using the row and column names

.. method:: proc NamedMatrix.update(i: int, j: int, w: real)

   
   Update the value in X(i,j) with `w`
    

.. method:: proc NamedMatrix.update(f: string, t: string, w: real)

   
   Update the value in X(i,j) with `w` using the row column names
    

.. function:: proc NamedMatrixFromPG(con: Connection, edgeTable: string, fromField: string, toField: string, wField: string = "NONE")

   
   Creates a NamedMatrix from a table in Postgres.  Does not optimize for square matrices.  This assumption
   is that the matrix is sparse.
   
   @TODO Appears that `forall` is causing problems.
   
   :arg string edgeTable: The SQL table holding the values of the matrix.
   :arg string fromField: The table column representing rows, e.g. `i`.
   :arg string toField: The table column representing columns, e.g. 'j'.
   :arg string wField: `default=NONE` the table column containing the values of cell `(i,j)``
   

.. function:: proc wFromPG(con: Connection, edgeTable: string, fromField: string, toField: string, wField: string, n: int, weights = true)

   
   
   :arg con: A CDO Connection to Postgres
   :arg edgeTable: The table in PG of edges
   :arg fromField: The field of edgeTable containing the id of the head vertex
   :arg toField: the field of edgeTable containing the id of the tail vertex
   :arg wField: The field of edgeTable containing the weight of the edge
   :arg n: number of distinct vertices. In practice, this may be gives and the number of names
   :arg weights: Boolean on whether to use the weights in the table or a 1 (indicator)
   

.. function:: proc wFromPG_(con: Connection, edgeTable: string, fromField: string, toField: string, wField: string, n: int, weights = true)

.. function:: proc vNamesFromPG(con: Connection, nameTable: string, nameField: string, idField: string)

   
   
   :arg con: A connection to a Postgres database containing a table with <ftr_id>, <vertex_name> pairs
   :arg nameTable: The name of the Postgres table containing the pairs
   :arg nameField: The name of the field in the nameTable containing the names
   :arg idField: The name of the field in the nameTable containing the feature ids
   
   :returns: An array of strings in order of feature id
   

.. function:: proc generateRandomSparseMatrix(size: int, sparsity: real)

   
   Build a random sparse matrix.  Good for testing;
   

.. function:: proc persistSparseMatrix(con: Connection, aTable: string, fromField: string, toField: string, weightField: string, X: [?D] real)

.. function:: proc persistSparseMatrix_(con: Connection, aTable: string, fromField: string, toField: string, weightField: string, X: [?D] real)

.. function:: proc persistSparseMatrix_P(con: Connection, aTable: string, fromField: string, toField: string, weightField: string, X: [?D] real)

.. function:: proc sparsity(X: [])

